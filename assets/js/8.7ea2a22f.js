(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{425:function(t,v,_){t.exports=_.p+"assets/img/lifecycle.b65dc1f4.png"},441:function(t,v,_){"use strict";_.r(v);var a=_(65),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"更新记录到工作区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新记录到工作区"}},[t._v("#")]),t._v(" 更新记录到工作区")]),t._v(" "),a("p",[t._v("工作目录下的每一个文件都只有："),a("strong",[t._v("已跟踪")]),t._v(" 或 "),a("strong",[t._v("未跟踪")]),t._v(" 两种状态。 已跟踪的文件是指那些被纳入了版本控制的文件，工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件。")]),t._v(" "),a("p",[t._v("编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为"),a("strong",[t._v("已修改")]),t._v("文件。 在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。")]),t._v(" "),a("p",[a("img",{attrs:{src:_(425),alt:"文件的状态变化周期"}})]),t._v(" "),a("h3",{attrs:{id:"检查当前文件状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#检查当前文件状态"}},[t._v("#")]),t._v(" 检查当前文件状态")]),t._v(" "),a("p",[t._v("可以用 "),a("code",[t._v("git status")]),t._v(" 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("$ "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" status\nOn branch master\nYour branch is up-to-date with "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'origin/master'")]),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(".")]),t._v("\nnothing to commit, working directory clean\n")])])]),a("p",[t._v("这说明所有已跟踪文件在上次提交后都未被更改过，而且当前目录下没有出现任何处于未跟踪状态的新文件。")]),t._v(" "),a("h3",{attrs:{id:"跟踪新文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跟踪新文件"}},[t._v("#")]),t._v(" 跟踪新文件")]),t._v(" "),a("p",[t._v("使用命令 "),a("code",[t._v("git add")]),t._v(" 开始跟踪一个文件。 所以，要跟踪 "),a("code",[t._v("README")]),t._v(" 文件，运行：")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("$ "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),t._v(" README\n")])])]),a("p",[a("code",[t._v("git add")]),t._v(" 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。")]),t._v(" "),a("h3",{attrs:{id:"暂存已修改的文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#暂存已修改的文件"}},[t._v("#")]),t._v(" 暂存已修改的文件")]),t._v(" "),a("p",[t._v("需要运行 "),a("code",[t._v("git add")]),t._v(" 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。")]),t._v(" "),a("h3",{attrs:{id:"状态简览"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态简览"}},[t._v("#")]),t._v(" 状态简览")]),t._v(" "),a("p",[t._v("使用 "),a("code",[t._v("git status -s")]),t._v(" 命令或 "),a("code",[t._v("git status --short")]),t._v(" 命令，你将得到一种格式更为紧凑的输出。")]),t._v(" "),a("p",[t._v("新添加的未跟踪文件前面有 "),a("code",[t._v("??")]),t._v(" 标记，新添加到暂存区中的文件前面有 "),a("code",[t._v("A")]),t._v(" 标记，修改过的文件前面有 "),a("code",[t._v("M")]),t._v(" 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。")]),t._v(" "),a("h3",{attrs:{id:"忽略文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#忽略文件"}},[t._v("#")]),t._v(" 忽略文件")]),t._v(" "),a("p",[t._v("创建一个名为 "),a("code",[t._v(".gitignore")]),t._v(" 的文件，列出要忽略的文件的模式。")]),t._v(" "),a("p",[t._v("文件 "),a("code",[t._v(".gitignore")]),t._v(" 的格式规范如下：")]),t._v(" "),a("ul",[a("li",[t._v("所有空行或者以 "),a("code",[t._v("#")]),t._v(" 开头的行都会被 Git 忽略。")]),t._v(" "),a("li",[t._v("可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。")]),t._v(" "),a("li",[t._v("匹配模式可以以（"),a("code",[t._v("/")]),t._v("）开头防止递归。")]),t._v(" "),a("li",[t._v("匹配模式可以以（"),a("code",[t._v("/")]),t._v("）结尾指定目录。")]),t._v(" "),a("li",[t._v("要忽略指定模式以外的文件或目录，可以在模式前加上叹号（"),a("code",[t._v("!")]),t._v("）取反。")])]),t._v(" "),a("p",[t._v("所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（"),a("code",[t._v("*")]),t._v("）匹配零个或多个任意字符；"),a("code",[t._v("[abc]")]),t._v(" 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（"),a("code",[t._v("?")]),t._v("）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 "),a("code",[t._v("[0-9]")]),t._v(" 表示匹配所有 0 到 9 的数字）。 使用两个星号（"),a("code",[t._v("**")]),t._v("）表示匹配任意中间目录，比如 "),a("code",[t._v("a/**/z")]),t._v(" 可以匹配 "),a("code",[t._v("a/z")]),t._v(" 、 "),a("code",[t._v("a/b/z")]),t._v(" 或 "),a("code",[t._v("a/b/c/z")]),t._v(" 等。")]),t._v(" "),a("h3",{attrs:{id:"查看已暂存和未暂存的修改"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查看已暂存和未暂存的修改"}},[t._v("#")]),t._v(" 查看已暂存和未暂存的修改")]),t._v(" "),a("p",[t._v("如果 "),a("code",[t._v("git status")]),t._v(" 命令的输出对于你来说过于简略，而你想知道具体修改了什么地方，可以用 "),a("code",[t._v("git diff")]),t._v(" 命令。 稍后我们会详细介绍 "),a("code",[t._v("git diff")]),t._v("，你通常可能会用它来回答这两个问题：当前做的哪些更新尚未暂存？ 有哪些更新已暂存并准备好下次提交？ 虽然 "),a("code",[t._v("git status")]),t._v(" 已经通过在相应栏下列出文件名的方式回答了这个问题，但 "),a("code",[t._v("git diff")]),t._v(" 能通过文件补丁的格式更加具体地显示哪些行发生了改变。")]),t._v(" "),a("p",[t._v("此命令比较的是工作目录中当前文件和暂存区域快照之间的差异（如果没有差异就不会有输出）。 也就是修改之后还没有暂存起来的变化内容。")]),t._v(" "),a("p",[t._v("若要查看已暂存的将要添加到下次提交里的内容，可以用 "),a("code",[t._v("git diff --staged")]),t._v(" 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异。")]),t._v(" "),a("p",[t._v("请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 "),a("code",[t._v("git diff")]),t._v(" 后却什么也没有，就是这个原因。")]),t._v(" "),a("p",[a("code",[t._v("git diff --cached")]),t._v(" 查看已经暂存起来的变化（ "),a("code",[t._v("--staged")]),t._v(" 和 "),a("code",[t._v("--cached")]),t._v(" 是同义词）")]),t._v(" "),a("h3",{attrs:{id:"提交更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提交更新"}},[t._v("#")]),t._v(" 提交更新")]),t._v(" "),a("p",[t._v("每次准备提交前，先用 "),a("code",[t._v("git status")]),t._v(" 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 "),a("code",[t._v("git commit")])]),t._v(" "),a("h3",{attrs:{id:"跳过使用暂存区域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跳过使用暂存区域"}},[t._v("#")]),t._v(" 跳过使用暂存区域")]),t._v(" "),a("p",[t._v("在提交的时候，给 "),a("code",[t._v("git commit")]),t._v(" 加上 "),a("code",[t._v("-a")]),t._v(" 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 "),a("code",[t._v("git add")]),t._v(" 步骤")]),t._v(" "),a("h3",{attrs:{id:"移除文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移除文件"}},[t._v("#")]),t._v(" 移除文件")]),t._v(" "),a("p",[t._v("要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 "),a("code",[t._v("git rm")]),t._v(" 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。")]),t._v(" "),a("p",[t._v("如果只是简单地从工作目录中手工删除文件，运行 "),a("code",[t._v("git status")]),t._v(" 时就会在 “Changes not staged for commit” 部分（也就是 "),a("em",[t._v("未暂存清单")]),t._v("）看到，然后再运行 "),a("code",[t._v("git rm")]),t._v(" 记录此次移除文件的操作，下一次提交时，该文件就不再纳入版本管理了。 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 "),a("code",[t._v("-f")]),t._v("（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删尚未添加到快照的数据，这样的数据不能被 Git 恢复。")]),t._v(" "),a("p",[t._v("另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 "),a("code",[t._v(".gitignore")]),t._v(" 文件，不小心把一个很大的日志文件或一堆 "),a("code",[t._v(".a")]),t._v(" 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 "),a("code",[t._v("--cached")]),t._v(" 选项：")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("$ "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("rm")]),t._v(" --cached README\n")])])]),a("h3",{attrs:{id:"移动文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移动文件"}},[t._v("#")]),t._v(" 移动文件")])])}),[],!1,null,null,null);v.default=s.exports}}]);