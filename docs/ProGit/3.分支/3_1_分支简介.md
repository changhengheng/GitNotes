# 分支简介总结

1. Git保存的是文件的快照
2. 提交时，Git会保存一个提交对象。提交对象包含两个指针，一个指向暂存内容的照，一个指向它的父对象。
   - 首次提交操作产生的提交对象没有父对象，它将成为下一次提交操作产生的提交对象的父对象。
   - 普通提交操作产生的提交对象有一个父对象（即上一次的提交对象）， 而由多个分支合并产生的提交对象有多个父对象（即各个分支原本的提交对象）。

3. 提交时，Git 会先计算每一个子目录的校验和，所谓校验和本质上是一个长度为 40 的 SHA-1 值的字符串的文件，然后将这些校验和保存为树对象（树对象的本质就是校验和）。校验和中的每个文件对应一个blob对象，保存着每一个文件的快照。随后Git会创建一个提交对象，其中包含了作者的姓名和邮箱、提交时输入的信息以及两个指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。
4. Git仓库中的三个对象：
   - *blob* 对象（保存着文件快照）、 **树** 对象 （记录着目录结构和 blob 对象索引）以及 **提交** 对象（包含着指向前述树对象的指针和所有提交信息）。
5. 分支的本质仅仅是指向提交对象的可变指针。Git 的默认分支名字是 `master`，多次提交会产生多个提交对象， `master` 分支会在每次提交时自动向前移动，指向最新的那一个提交对象。
6. 创建分支本质上只是创建了一个可以移动的新的指针，使用 `git branch` 命令以在当前所在的提交对象上创建一个指针。也就是说，如果当前仓库是干净的，所有文件的都被提交到仓库区，然后你创建了一个 `test` 分支，那么这个 `tset` 分支本质上是一个指针，它指向这个最新的提交对象，当你切换到 `test` 分支进行工作，再次进行提交操作时，会产生新的提交对象，此时 `test`会自动向前移动以指向最新的提交对象，就从原来的 `master` 分支上分叉出去了，原来的 `master` 分支还是由 `master` 这个指针跟踪着。

7. Git有一个名为 `HEAD` 的特殊指针，始终指向当前所在的本地分支（本地分支是一个指向当前提交对象的指针，这个HEAD指针也是提交对象的指针，也指向当前本地分支指向的提交对象，它们两是同级的，但是作用不同）。相当于现在有 `master` 世界线和 `test` 世界线，两条世界线互不干扰，master世界线由master在观察，test世界线由test在观察，然而这个`HEAD`是个Bug，它有命运探知之魔眼的能力，知道所有世界线的存在，它还是个跟屁虫，你跑到哪个世界线它就跟到哪儿，它始终处于当前你所在的那个分支上。

8. 使用 `git log --decorate` 命令查看各个分支当前所指的对象。
9. 使用 `git checkout branchname` 切换到某一分支，切换过去的时候，HEAD指针就指向这个分支了（跟屁虫）。在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。

10. 你可以简单地使用 `git log` 命令查看分叉历史。 
11. 通常我们会在创建一个新分支后立即切换过去，这可以用 `git checkout -b <newbranchname>` 一条命令搞定。